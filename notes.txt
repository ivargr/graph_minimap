python3 map.py sim.fa testindex whole_genome.graphs.npz
python3 map.py human_data/sim.fa human_data/index_all_chr human_data/whole_genome.graphs.npz

python3 map.py sim_5k.fa index_chr6_new whole_genome.graphs.npz 1 aligned.gma


- Lage critical nodes på nytt for whole genome
- Lage indeks per krom på nytt for whole genome. Skal vi lage med w = 5 ??
    - Kunne kanskje vært interesssant å prøve mhc med w = 7 og se om det gir stor forskjell
    - Interessant å se hvor mange flere minimizers det blir.
- Merge indeksene

Plan nå:
    - Fullføre ny index på helgenom
        + Lag nye critical nodes
        + Sett på ny create_index.py
        - Kjør merge_minimizer_dbs
    - Sjekke mapping på helgenom, debugge, antar det bør være mulig å få bra resultater
    - Når bra resultater, kjør two-step mapping
    - Hvis ikke bra resultater, dropp hele minimap for nå, fullfør artikkel uten


rsync --exclude *.db* --exclude *.np* --exclude mhc_graph/ --exclude human_data/ --exclude mhc_graph2/ --exclude *.fa --exclude *.tsv -avp graph_minimap root@ivarg.ddns.net:/home/ivar/dev/.

vg 10m: 39m 16 threads


# Find critical nodes
chromosomes="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X"
for chrom in $(echo $chromosomes | tr "," "\n")
	do
    python3 /home/ivar/dev/graph_minimap/graph_minimap/critical_nodes.py $chrom ./ &
done


# Make index for each chromosome
chromosomes="1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X"
for chrom in $(echo $chromosomes | tr "," "\n")
	do
    python3 /home/ivar/dev/graph_minimap/create_index.py $chrom /data/bioinf/human_1pc/ $chrom &
done

Plan nå:
    - Kanskje på tide å skrive lokal-aligneren og se hvor tregt det blir?
        - Dette er egentlig det eneste ordenlige som gjenstår før hele mappingen virker
        - Tanken er å lokal-aligne bare mellom anchors og bruke singlereadaligner.
            - Koden som trengs er egentlig bare å finne ut hvilke biter som skal alignes, aligne hver av dem og lime bitene sammen
        - Et problem er nok at vi kanskje også må aligne anchorsene, for vi vil vite grafstien til dem
        - Sånn-sett enklest å bare aligne fra første anchor i begge retninger.o

       - Bør kunne bruke striped smith  waterman pakken til å lokalaligne til grafen.
            - Kan det være verdt å lage noe litt bedre som ikke gjør grådig valg av neste node?
            - Alternativt kan man traversere grafen og slå opp f. eks neste 10 basepar alle mulige stier
                - Først prøver man lineær-ref, hvis den gir 100% match, så dropper man andre stier

            - Kan bruke en rekursiv metode som gjør dybde først aligning gjennom grafen.
                - Stopp traverseringen hvis antall mismatcher blir for stor
                - Stopp traverseringen hvis man har besøkt noden før med betydelig høyere score

        - En mulighet for speedup er å slå opp neste X base par (X litt større enn antall basepar i read) fremover i grafen ved å følge lineær-ref, og så kjøre
        smith-waterman mot den sekvensen. Det vil sannsynligvis gi en CIGAR som gjør at man kan resolve hvilke varianter readen passer til
            - Man kan da traversere grafen med cigar-en

        - evt (tror dette er beste løsning):
            - Forsøk å traversere dybde først alle mulige stier som har read-lengden, bruk noen heuristics for å begrense søket
                - Hver gang en full sti er traversert, kjør sw mot den
                - Gå tilbake til posisjonen der første mismatch/insertion/deletion i sw-resultatet starter, traverser på nytt derifra
                    - ikke velg noder som allerede er valgt, traverser fram til read lengden (pluss litt)
                - Gjenta prosessen
                    - Vi kan stoppe hvis man ikke får bedre alignment score gjentatte ganger
        - En variant av den over som er enklere å kode og kanskje raskere:
            - Finn først en sti (prioriter lineær-ref) som er like lang som read length
            - Align mot den
            - Modifiser stien ved å velge andre veier i første veikryss (assume alle andre veier går tilbake til stien ved neste edge igjen)
            - Align mot alle de mulige stiene
                - Velg den som gir høyest score, hvis ingen gir høyere score enn første alignment, stopp
            - Gjenta ved neste stivalg helt til slutten av readen
            - Dette blir et slags grådig søk ved hvert veikryss, men forskjellen fra opprinnelig approach er at man bruker resten av readen til å vurdere

        Altså:
            - Traverser fremover, ved første veikryss, finn alle mulige stier som er read length lange, prioriter lineær ref-
            - Align til alle de stiene, velg den med høyest score
            - Gå til neste veikryss, finn alle mulige stier som er read length lange, align til dem
            - Gjenta ...

time python3 ../graph_minimap/map.py sim.fa minimizers_all.db /data/bioinf/human_1pc/ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X
time python3 -m cProfile -s tottime ../graph_minimap/map.py sim.fa minimizers_all.db /data/bioinf/human_1pc/ 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,X | head -n 150
time python3 ../graph_minimap/map.py sim.fa minimizers_chr20.db /data/bioinf/human_1pc/ 20


Numpy index for minimizers:
    - 279 mill minimizers for hele genomet (kanskje dobbelt så mange senere)
    - En dict fra hash til int64 som gir index posisjon
    - En dict fra hash til int16 som gir antall minimizers
    - En int64 array som gir ref pos
    - int32 som gir node
    - int8 som gir node offset
    - int8 som gir kromosom
    = 112 bits per minimizer = 3.7 GB
    - Spørsmålet er hvor mye minne 270 mill elementer i dict tar



